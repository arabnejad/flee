{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Simulation toolkit for the movement of individuals \u00b6 Flee is an agent-based modelling toolkit which is purpose-built for simulating the movement of individuals across geographical locations, released under a BSD 3-clause license. Flee is currently used for modelling the movements of refugees and internally displaced persons (IDPs). It provides users with the ability to define and use their models through a relatively straightforward application programming interface (API). There are a range of functional tests to allow users to verify the consistency of the code results. FLEE also features a range of scripts to handle and convert data, as well as an automated plotting tool for output generated by the simulation. Flee is publicly available at: https://github.com/djgroen/flee","title":"Introduction"},{"location":"#simulation-toolkit-for-the-movement-of-individuals","text":"Flee is an agent-based modelling toolkit which is purpose-built for simulating the movement of individuals across geographical locations, released under a BSD 3-clause license. Flee is currently used for modelling the movements of refugees and internally displaced persons (IDPs). It provides users with the ability to define and use their models through a relatively straightforward application programming interface (API). There are a range of functional tests to allow users to verify the consistency of the code results. FLEE also features a range of scripts to handle and convert data, as well as an automated plotting tool for output generated by the simulation. Flee is publicly available at: https://github.com/djgroen/flee","title":"Simulation toolkit for the movement of individuals"},{"location":"Installation_and_Testing/","text":"Dependencies \u00b6 To use the Flee code, one requires: Python 3 interpreter Python libraries numpy (see https://www.numpy.org ) pandas (see https://pandas.pydata.org ) matplotlib (see https://matplotlib.org ) scipy (see https://scipy.org ) git needs to be installed in your machine. Installing Flee \u00b6 To install Flee on your local workstation, you need to clone the Flee repository: git clone https://github.com/djgroen/flee.git Once cloning completes, Flee will appear in your working directory as <current dir>/flee . Updating Flee \u00b6 If you have already installed Flee and want to update to the latest version, in your local Flee directory simply type git pull Testing Flee \u00b6 To run the test example, simply type cd flee python3 tests/test_csv.py","title":"Installation and Testing"},{"location":"Installation_and_Testing/#dependencies","text":"To use the Flee code, one requires: Python 3 interpreter Python libraries numpy (see https://www.numpy.org ) pandas (see https://pandas.pydata.org ) matplotlib (see https://matplotlib.org ) scipy (see https://scipy.org ) git needs to be installed in your machine.","title":"Dependencies"},{"location":"Installation_and_Testing/#installing-flee","text":"To install Flee on your local workstation, you need to clone the Flee repository: git clone https://github.com/djgroen/flee.git Once cloning completes, Flee will appear in your working directory as <current dir>/flee .","title":"Installing Flee"},{"location":"Installation_and_Testing/#updating-flee","text":"If you have already installed Flee and want to update to the latest version, in your local Flee directory simply type git pull","title":"Updating Flee"},{"location":"Installation_and_Testing/#testing-flee","text":"To run the test example, simply type cd flee python3 tests/test_csv.py","title":"Testing Flee"},{"location":"Simulation_instance_construction/","text":"Simulation instance construction \u00b6 This documentation details how to construct a conflict scenario for forced displacement simulation. Each conflict situation requires input data (in input_csv directory), validation data (in source_data directory) and execution scripts ( run.py , run_par.py and simsetting.csv ) as illustrated below: To create input and validation data files, the following forced displacement databases are considered: the Armed Conflict Location and Event Data Project (ACLED, https://www.acleddata.com/data ); the United Nations High Commissioner for Refugees database (UNHCR, https://data2.unhcr.org/en/situations ); the population databases (e.g. https://www.citypopulation.de ); the geospatial databases (e.g. https://www.openstreetmap.org or http://www.bing.com/maps ). Construct an input locations.csv file \u00b6 ACLED conflict locations extraction \u00b6 The ACLED database provides conflict location data for forced displacement simulations. To obtain data on chosen conflict situation, complete the ACLED data export tool fields ( https://acleddata.com/acleddatanew/data-export-tool/ ) as follows: Provide dates of interest for conflict situation (i.e. From and To). Select Event Type: Battle . Select Sub Event Type Armed clash, Attack, Government regains territory and Non-state actor overtakes territory. Specify Region and Country of conflict situation choice. Click on Export and Accept Terms of Use and Attribution Policy. Click Export again and <name>.csv file exports to Downloads automatically. The ACLED conflict data provides conflict locations to construct locations.csv input file for simulation purposes. After identifying conflict locations and producing locations.csv , the last column is filled with population data for conflict locations. name region country lat long location_type conflict_date population/capacity A AA ABC xxx xxx conflict xxx xxx B BB ABC xxx xxx conflict xxx xxx C CC ABC xxx xxx conflict xxx xxx ... ... ... ... ... ... ... ... UNHCR forced migrant counts and camp locations extraction \u00b6 The UNHCR situations provides an overview of active situations worldwide that are facing forced displacement distress. To construct a new conflict situation: Select an active (conflict) situation of interest from an interactive map and click to access data and documentation relevant to a chosen conflict situation from https://data2.unhcr.org/en/situations . Select a simulation period for conflict situation from Refugees and asylum-seekers from 'chosen situation name' - Total timeline , which also presents forced displacement counts for a chosen period. Obtain total counts of forcibly displaced people by clicking JSON button of Refugees and asylum-seekers from 'chosen situation name' - Total section . Identify camps for each neighbouring country through Breakdown by Country section of the conflict situation. Collect and save data for each camp (e.g. <country_name-camp_name>.csv ). Input camp names (i.e. destination locations) and their capacity into locations.csv file. Camp capacity is the highest number of forced migrants for each camp and obtained from individual camp CSV files that are set in locations.csv . For instance, CampZ.csv has the highest number of forcibly displaced people (18129) on 2015-09-30, which is the camp capacity for CampZ. ... ... 2015-03-31 11470 2015-06-02 12405 2015-07-24 12405 2015-08-31 11359 2015-09-30 18129 ... ... Population data extraction \u00b6 Currently, the population figures for each location will need to be collected and written to the population/capacity column from www.citypopulation.de . After the population data has been collected for each location, input these population numbers in locations.csv , which can be then used for simulation execution. Construct an input routes.csv file \u00b6 Identified conflict zones and camps provide origin and destination locations. We connect these locations to represent how forcibly displaced people flee. We use https://www.openstreetmap.org or http://www.bing.com/maps (or other mapping services) to connect conflict zones and camps, and add additional locations (if required) as a location type town to locations.csv as illustrated below: name region country lat long location_type conflict_date population/capacity A AA ABC xxx xxx conflict xxx xxx B BB ABC xxx xxx conflict xxx xxx C CC ABC xxx xxx conflict xxx xxx Z ZZ ZZZ xxx xxx camp xxx N NN ABC xxx xxx town ... ... ... ... ... ... ... ... Record distances between locations in routes.csv file for simulation using the following format: name1 name2 distance[km] forced_redirection A B x1 B C x2 A C x3 B N x4 C N x3 N Z x5 ... ... ... ... forced_redirection refers to redirection from source location (can be town or camp) to destination location (mainly camp) and source location indicated as forwarding_hub. The value of 0 indicates no redirection, 1 indicates redirection (from name2) to name1 and 2 corresponds to redirection (from name1) to name2. Define location and border closures in closures.csv file \u00b6 We identify location or border closure events and document them in closures.csv file: closure_type name1 name2 closure_start = 0 closure_end = -1 location A B xxx xxx country ABC ZZZ xxx xxx ... ... ... ... ... closure_type has 2 possible values: location corresponding to camp or town closure and country referring to border closure. closure_start and closure_end are given as integers, counting the number of days after the simulation start. The value of 0 indicates the start, while -1 indicates the end of the simulation. Define a conflict period for a conflict situation \u00b6 We define the simulation period of a conflict situation using conflict_period.csv file, which has the following format: StartDate YYYY-MM-DD Length simulation_period Record conflict locations in conflicts.csv file \u00b6 We create a conflicts.csv file to record conflict locations indicating the start of conflicts in the simulation execution (represented as 1 ): #Day name A B C Z 0 0 1 0 0 0 1 0 1 0 0 0 2 0 1 1 0 0 3 0 1 1 0 0 4 0 1 1 1 0 5 0 1 1 1 0 ... ... ... ... ... ... Construct a network map for a conflict situation \u00b6 Construct an agent-based network map from locations.csv and routes.csv using https://carto.com . Construct validation data \u00b6 There are three CSV file formats required for validation of simulation outputs. CSV file containing total forced migrant counts refugees.csv comprises total counts of forcibly displaced people from Refugees and asylum-seekers from 'chosen situation name' - Total JSON file and has the format as demonstrated: ... ... YYYY-MM-DD xxx YYYY-MM-DD xxx ... ... We obtain data for each camp using the format and label them as country_name-camp_name.csv : ... ... YYYY-MM-DD xxx YYYY-MM-DD xxx ... ... data_layout.csv contains camp names for each camp/destination locations: total refugees.csv camp_name1 country_name-camp_name1.csv camp_name2 country_name-camp_name2.csv ... ...","title":"Simulation instance construction"},{"location":"Simulation_instance_construction/#simulation-instance-construction","text":"This documentation details how to construct a conflict scenario for forced displacement simulation. Each conflict situation requires input data (in input_csv directory), validation data (in source_data directory) and execution scripts ( run.py , run_par.py and simsetting.csv ) as illustrated below: To create input and validation data files, the following forced displacement databases are considered: the Armed Conflict Location and Event Data Project (ACLED, https://www.acleddata.com/data ); the United Nations High Commissioner for Refugees database (UNHCR, https://data2.unhcr.org/en/situations ); the population databases (e.g. https://www.citypopulation.de ); the geospatial databases (e.g. https://www.openstreetmap.org or http://www.bing.com/maps ).","title":"Simulation instance construction"},{"location":"Simulation_instance_construction/#construct-an-input-locationscsv-file","text":"","title":"Construct an input locations.csv file"},{"location":"Simulation_instance_construction/#acled-conflict-locations-extraction","text":"The ACLED database provides conflict location data for forced displacement simulations. To obtain data on chosen conflict situation, complete the ACLED data export tool fields ( https://acleddata.com/acleddatanew/data-export-tool/ ) as follows: Provide dates of interest for conflict situation (i.e. From and To). Select Event Type: Battle . Select Sub Event Type Armed clash, Attack, Government regains territory and Non-state actor overtakes territory. Specify Region and Country of conflict situation choice. Click on Export and Accept Terms of Use and Attribution Policy. Click Export again and <name>.csv file exports to Downloads automatically. The ACLED conflict data provides conflict locations to construct locations.csv input file for simulation purposes. After identifying conflict locations and producing locations.csv , the last column is filled with population data for conflict locations. name region country lat long location_type conflict_date population/capacity A AA ABC xxx xxx conflict xxx xxx B BB ABC xxx xxx conflict xxx xxx C CC ABC xxx xxx conflict xxx xxx ... ... ... ... ... ... ... ...","title":"ACLED conflict locations extraction"},{"location":"Simulation_instance_construction/#unhcr-forced-migrant-counts-and-camp-locations-extraction","text":"The UNHCR situations provides an overview of active situations worldwide that are facing forced displacement distress. To construct a new conflict situation: Select an active (conflict) situation of interest from an interactive map and click to access data and documentation relevant to a chosen conflict situation from https://data2.unhcr.org/en/situations . Select a simulation period for conflict situation from Refugees and asylum-seekers from 'chosen situation name' - Total timeline , which also presents forced displacement counts for a chosen period. Obtain total counts of forcibly displaced people by clicking JSON button of Refugees and asylum-seekers from 'chosen situation name' - Total section . Identify camps for each neighbouring country through Breakdown by Country section of the conflict situation. Collect and save data for each camp (e.g. <country_name-camp_name>.csv ). Input camp names (i.e. destination locations) and their capacity into locations.csv file. Camp capacity is the highest number of forced migrants for each camp and obtained from individual camp CSV files that are set in locations.csv . For instance, CampZ.csv has the highest number of forcibly displaced people (18129) on 2015-09-30, which is the camp capacity for CampZ. ... ... 2015-03-31 11470 2015-06-02 12405 2015-07-24 12405 2015-08-31 11359 2015-09-30 18129 ... ...","title":"UNHCR forced migrant counts and camp locations extraction"},{"location":"Simulation_instance_construction/#population-data-extraction","text":"Currently, the population figures for each location will need to be collected and written to the population/capacity column from www.citypopulation.de . After the population data has been collected for each location, input these population numbers in locations.csv , which can be then used for simulation execution.","title":"Population data extraction"},{"location":"Simulation_instance_construction/#construct-an-input-routescsv-file","text":"Identified conflict zones and camps provide origin and destination locations. We connect these locations to represent how forcibly displaced people flee. We use https://www.openstreetmap.org or http://www.bing.com/maps (or other mapping services) to connect conflict zones and camps, and add additional locations (if required) as a location type town to locations.csv as illustrated below: name region country lat long location_type conflict_date population/capacity A AA ABC xxx xxx conflict xxx xxx B BB ABC xxx xxx conflict xxx xxx C CC ABC xxx xxx conflict xxx xxx Z ZZ ZZZ xxx xxx camp xxx N NN ABC xxx xxx town ... ... ... ... ... ... ... ... Record distances between locations in routes.csv file for simulation using the following format: name1 name2 distance[km] forced_redirection A B x1 B C x2 A C x3 B N x4 C N x3 N Z x5 ... ... ... ... forced_redirection refers to redirection from source location (can be town or camp) to destination location (mainly camp) and source location indicated as forwarding_hub. The value of 0 indicates no redirection, 1 indicates redirection (from name2) to name1 and 2 corresponds to redirection (from name1) to name2.","title":"Construct an input routes.csv file"},{"location":"Simulation_instance_construction/#define-location-and-border-closures-in-closurescsv-file","text":"We identify location or border closure events and document them in closures.csv file: closure_type name1 name2 closure_start = 0 closure_end = -1 location A B xxx xxx country ABC ZZZ xxx xxx ... ... ... ... ... closure_type has 2 possible values: location corresponding to camp or town closure and country referring to border closure. closure_start and closure_end are given as integers, counting the number of days after the simulation start. The value of 0 indicates the start, while -1 indicates the end of the simulation.","title":"Define location and border closures in closures.csv file"},{"location":"Simulation_instance_construction/#define-a-conflict-period-for-a-conflict-situation","text":"We define the simulation period of a conflict situation using conflict_period.csv file, which has the following format: StartDate YYYY-MM-DD Length simulation_period","title":"Define a conflict period for a conflict situation"},{"location":"Simulation_instance_construction/#record-conflict-locations-in-conflictscsv-file","text":"We create a conflicts.csv file to record conflict locations indicating the start of conflicts in the simulation execution (represented as 1 ): #Day name A B C Z 0 0 1 0 0 0 1 0 1 0 0 0 2 0 1 1 0 0 3 0 1 1 0 0 4 0 1 1 1 0 5 0 1 1 1 0 ... ... ... ... ... ...","title":"Record conflict locations in conflicts.csv file"},{"location":"Simulation_instance_construction/#construct-a-network-map-for-a-conflict-situation","text":"Construct an agent-based network map from locations.csv and routes.csv using https://carto.com .","title":"Construct a network map for a conflict situation"},{"location":"Simulation_instance_construction/#construct-validation-data","text":"There are three CSV file formats required for validation of simulation outputs. CSV file containing total forced migrant counts refugees.csv comprises total counts of forcibly displaced people from Refugees and asylum-seekers from 'chosen situation name' - Total JSON file and has the format as demonstrated: ... ... YYYY-MM-DD xxx YYYY-MM-DD xxx ... ... We obtain data for each camp using the format and label them as country_name-camp_name.csv : ... ... YYYY-MM-DD xxx YYYY-MM-DD xxx ... ... data_layout.csv contains camp names for each camp/destination locations: total refugees.csv camp_name1 country_name-camp_name1.csv camp_name2 country_name-camp_name2.csv ... ...","title":"Construct validation data"},{"location":"Simulation_instance_execution/","text":"Execute test instance \u00b6 To run simulation instance using Flee with test, simply type: python3 run_csv_vanilla.py test_data/test_input_csv test_data/test_input_csv/refugee_data 5 2010 -01-01 2 >/dev/null Note The 2>/dev/null ensures that any diagnostics are not displayed on the screen. Instead, pure CSV output for the toy model should appear on the screen if this works correctly. Execute a conflict scenario \u00b6 Create an output directory out<country_name> , where <country_name> refers to a conflict instance name. For instance, create an output directory outcar for the Central African Republic (CAR) situation. mkdir outcar Execute a conflict scenario by following the execution template demonstrated below: python3 conflicts/<country_name>.py <simulation_period> > out<country_name>/out.csv where conflicts/<country_name>.py is a conflict instance script, <simulation_period> represents the simulation duration and out<country_name>/out.csv stores the simulation output. For example, execute car-csv.py in the conflicts directory for the simulation duration of 50 days and store the simulation output in outcar/out.csv : python3 conflicts/car-csv.py 50 > outcar/out.csv To plot the simulation output, simply follow the command template below: python3 plot-flee-output.py out<country_name> where out<country_name> represents the simulation output directory (Step 1). To illustrate, plot the simulation output for CAR, simply execute: python3 plot-flee-output.py outcar To analyse and interpret simulation output, open out<country_name> , which will contain simulation output and UNHCR data comparison graphs for each camp, as well as average relative difference graph for the simulated conflict situation. To illustrate, analyse and interpret simulation output graphs in the outcar directory. Parallel Performance Testing \u00b6 Parallel tests can be performed using test_par.py. The interface is as follows: mpirun -np [ number of cores ] python3 tests/test_par.py [ options ] Options can be as follows: \"-p\" , \"--parallelmode\" - Parallelization mode ([ advanced ] , classic, cl-hilat OR adv-lowlat ) . \"-N\" , \"--initialagents\" - Number of agents at the start of the simulation [ 100000 ] . \"-d\" , \"--newagentsperstep\" , Number of agents added per time step [ 1000 ] . \"-t\" , \"--simulationperiod\" , Duration of the simulation in days [ 10 ] . Here are a few settings good for benchmarking: mpirun -np <cores> python3 test_par.py -N 500000 -p advanced -d 10000 -t 10 mpirun -np <cores> python3 test_par.py -N 500000 -p classic -d 10000 -t 10 mpirun -np <cores> python3 test_par.py -N 500000 -p cl-hilat -d 10000 -t 10 mpirun -np <cores> python3 test_par.py -N 500000 -p adv-lowlat -d 10000 -t 10","title":"Simulation instance execution"},{"location":"Simulation_instance_execution/#execute-test-instance","text":"To run simulation instance using Flee with test, simply type: python3 run_csv_vanilla.py test_data/test_input_csv test_data/test_input_csv/refugee_data 5 2010 -01-01 2 >/dev/null Note The 2>/dev/null ensures that any diagnostics are not displayed on the screen. Instead, pure CSV output for the toy model should appear on the screen if this works correctly.","title":"Execute test instance"},{"location":"Simulation_instance_execution/#execute-a-conflict-scenario","text":"Create an output directory out<country_name> , where <country_name> refers to a conflict instance name. For instance, create an output directory outcar for the Central African Republic (CAR) situation. mkdir outcar Execute a conflict scenario by following the execution template demonstrated below: python3 conflicts/<country_name>.py <simulation_period> > out<country_name>/out.csv where conflicts/<country_name>.py is a conflict instance script, <simulation_period> represents the simulation duration and out<country_name>/out.csv stores the simulation output. For example, execute car-csv.py in the conflicts directory for the simulation duration of 50 days and store the simulation output in outcar/out.csv : python3 conflicts/car-csv.py 50 > outcar/out.csv To plot the simulation output, simply follow the command template below: python3 plot-flee-output.py out<country_name> where out<country_name> represents the simulation output directory (Step 1). To illustrate, plot the simulation output for CAR, simply execute: python3 plot-flee-output.py outcar To analyse and interpret simulation output, open out<country_name> , which will contain simulation output and UNHCR data comparison graphs for each camp, as well as average relative difference graph for the simulated conflict situation. To illustrate, analyse and interpret simulation output graphs in the outcar directory.","title":"Execute a conflict scenario"},{"location":"Simulation_instance_execution/#parallel-performance-testing","text":"Parallel tests can be performed using test_par.py. The interface is as follows: mpirun -np [ number of cores ] python3 tests/test_par.py [ options ] Options can be as follows: \"-p\" , \"--parallelmode\" - Parallelization mode ([ advanced ] , classic, cl-hilat OR adv-lowlat ) . \"-N\" , \"--initialagents\" - Number of agents at the start of the simulation [ 100000 ] . \"-d\" , \"--newagentsperstep\" , Number of agents added per time step [ 1000 ] . \"-t\" , \"--simulationperiod\" , Duration of the simulation in days [ 10 ] . Here are a few settings good for benchmarking: mpirun -np <cores> python3 test_par.py -N 500000 -p advanced -d 10000 -t 10 mpirun -np <cores> python3 test_par.py -N 500000 -p classic -d 10000 -t 10 mpirun -np <cores> python3 test_par.py -N 500000 -p cl-hilat -d 10000 -t 10 mpirun -np <cores> python3 test_par.py -N 500000 -p adv-lowlat -d 10000 -t 10","title":"Parallel Performance Testing"},{"location":"code_reference/flee_ecosystem/","text":"Ecosystem class \u00b6 a base class for Ecosystem object Attributes: Name Type Description agents list Description closures list Description conflict_pop int Description conflict_weights TYPE Description conflict_zone_names list Description conflict_zones list Description locationNames list Description locations list Description num_arrivals list Description print_location_output bool Description time int Description travel_durations list Description Methods \u00b6 add_agents_to_conflict_zones ( self , number ) \u00b6 Add a group of agents, distributed across conflict zones. Parameters: Name Type Description Default number TYPE Description required Source code in flee/flee.py def add_agents_to_conflict_zones ( self , number ): \"\"\" Add a group of agents, distributed across conflict zones. Args: number (TYPE): Description \"\"\" cl = self . pick_conflict_locations ( number ) for i in range ( 0 , number ): self . addAgent ( cl [ i ]) add_conflict_zone ( self , name , change_movechance = True ) \u00b6 Adds a conflict zone. Default weight is equal to population of the location. Parameters: Name Type Description Default name TYPE Description required change_movechance bool Description True Returns: Type Description TYPE Description Source code in flee/flee.py def add_conflict_zone ( self , name , change_movechance = True ): \"\"\" Adds a conflict zone. Default weight is equal to population of the location. Args: name (TYPE): Description change_movechance (bool, optional): Description Returns: TYPE: Description \"\"\" for i in range ( 0 , len ( self . locationNames )): if self . locationNames [ i ] == name : if name not in self . conflict_zone_names : if change_movechance : self . locations [ i ] . movechance = ( SimulationSettings . ConflictMoveChance ) self . locations [ i ] . conflict = True self . locations [ i ] . town = False self . conflict_zone_names += [ name ] self . conflict_zones += [ self . locations [ i ]] self . conflict_weights = np . append ( self . conflict_weights , [ self . locations [ i ] . pop ]) self . conflict_pop = sum ( self . conflict_weights ) if SimulationSettings . InitLogLevel > 0 : print ( \"Added conflict zone:\" , name , \", pop. \" , self . locations [ i ] . pop ) print ( \"New total pop. in conflict zones: \" , self . conflict_pop ) return print ( \"Diagnostic: self.locationNames: \" , self . locationNames ) print ( \"ERROR in flee.add_conflict_zone: location with name [ {} ] appears\" \" not to exist in the FLEE ecosystem \" \"(see diagnostic above).\" . format ( name ) ) addAgent ( self , location ) \u00b6 Add an agent to the location object Parameters: Name Type Description Default location Link location object required Source code in flee/flee.py def addAgent ( self , location ): \"\"\" Add an agent to the location object Args: location (Link): location object \"\"\" if SimulationSettings . TakeRefugeesFromPopulation : if location . conflict : if location . pop > 0 : location . pop -= 1 location . numAgentsSpawned += 1 else : print ( \"ERROR: Number of agents in the simulation is \" \"larger than the combined population of the conflict\" \" zones. Please amend locations.csv.\" ) location . print () assert location . pop > 1 self . agents . append ( Person ( location )) addLocation ( self , name , x = '0.0' , y = '0.0' , movechance = 0.3 , capacity =- 1 , pop = 0 , foreign = False , country = 'unknown' ) \u00b6 Add a location to the ABM network graph Parameters: Name Type Description Default name TYPE Description required x str Description '0.0' y str Description '0.0' movechance TYPE Description 0.3 capacity TYPE Description -1 pop int Description 0 foreign bool Description False country str Description 'unknown' Returns: Type Description TYPE location object (Link class) Source code in flee/flee.py def addLocation ( self , name , x = \"0.0\" , y = \"0.0\" , movechance = SimulationSettings . DefaultMoveChance , capacity =- 1 , pop = 0 , foreign = False , country = \"unknown\" ): \"\"\" Add a location to the ABM network graph Args: name (TYPE): Description x (str, optional): Description y (str, optional): Description movechance (TYPE, optional): Description capacity (TYPE, optional): Description pop (int, optional): Description foreign (bool, optional): Description country (str, optional): Description Returns: TYPE: location object (Link class) \"\"\" l = Location ( name , x , y , movechance , capacity , pop , foreign , country ) if SimulationSettings . InitLogLevel > 0 and self . print_location_output : print ( \"Location:\" , name , x , y , l . movechance , capacity , \", pop. \" , pop , foreign ) self . locations . append ( l ) self . locationNames . append ( l . name ) return l clearLocationsFromAgents ( self , location_names ) \u00b6 Remove all agents from a list of locations by name. Useful for couplings to other simulation codes. Parameters: Name Type Description Default location_names TYPE Description required Source code in flee/flee.py def clearLocationsFromAgents ( self , location_names ): \"\"\" Remove all agents from a list of locations by name. Useful for couplings to other simulation codes. Args: location_names (TYPE): Description \"\"\" new_agents = [] for i in range ( 0 , len ( self . agents )): if self . agents [ i ] . location . name not in location_names : new_agents += agents [ i ] # agent is preserved in ecosystem else : # agent is removed from the ecosystem and number of agents # drops by one. self . agents [ i ] . location . DecrementNumAgents () self . agents = new_agents close_border ( self , source_country , dest_country , twoway = True , Debug = False ) \u00b6 Close all links between two countries. Parameters: Name Type Description Default source_country TYPE Description required dest_country TYPE Description required twoway bool if False , only links from source to destination will be closed True Debug bool Description False Source code in flee/flee.py def close_border ( self , source_country , dest_country , twoway = True , Debug = False ): \"\"\" Close all links between two countries. Args: source_country (TYPE): Description dest_country (TYPE): Description twoway (bool, optional): if `False`, only links from source to destination will be closed Debug (bool, optional): Description \"\"\" self . _change_border_1way ( source_country , dest_country , mode = \"close\" , Debug = Debug ) if twoway : self . _change_border_1way ( dest_country , source_country , mode = \"close\" , Debug = Debug ) close_link ( self , startpoint , endpoint , twoway = True ) \u00b6 Shorthand call for remove_link, only moving the link to the closed list. Parameters: Name Type Description Default startpoint TYPE Description required endpoint TYPE Description required twoway bool Description True Returns: Type Description TYPE Description Source code in flee/flee.py def close_link ( self , startpoint , endpoint , twoway = True ): \"\"\" Shorthand call for remove_link, only moving the link to the closed list. Args: startpoint (TYPE): Description endpoint (TYPE): Description twoway (bool, optional): Description Returns: TYPE: Description \"\"\" return self . remove_link ( startpoint , endpoint , twoway = twoway , close_only = True ) close_location ( self , location_name , twoway = True , Debug = False ) \u00b6 Close in- and outgoing links for a location. Parameters: Name Type Description Default location_name TYPE Description required twoway bool Description True Debug bool Description False Returns: Type Description TYPE Description Source code in flee/flee.py def close_location ( self , location_name , twoway = True , Debug = False ): \"\"\" Close in- and outgoing links for a location. Args: location_name (TYPE): Description twoway (bool, optional): Description Debug (bool, optional): Description Returns: TYPE: Description \"\"\" if twoway : return self . _change_location_1way ( location_name , mode = \"close\" , direction = \"both\" , Debug = Debug ) else : return self . _change_location_1way ( location_name , mode = \"close\" , direction = \"in\" , Debug = Debug ) enact_border_closures ( self , time , twoway = True , Debug = False ) \u00b6 Summary Parameters: Name Type Description Default time TYPE Description required twoway bool Description True Debug bool Description False Source code in flee/flee.py def enact_border_closures ( self , time , twoway = True , Debug = False ): \"\"\" Summary Args: time (TYPE): Description twoway (bool, optional): Description Debug (bool, optional): Description \"\"\" # print(\"Enact border closures: \", self.closures) if len ( self . closures ) > 0 : for c in self . closures : if time == c [ 3 ]: if c [ 0 ] == \"country\" : if Debug : print ( \"Time = {} . Closing Border between \" \"[ {} ] and [ {} ]\" . format ( time , c [ 1 ], c [ 2 ]), file = sys . stderr ) self . close_border ( c [ 1 ], c [ 2 ], twoway ) if c [ 0 ] == \"location\" : self . close_location ( c [ 1 ], twoway ) if c [ 0 ] == \"link\" : self . close_link ( c [ 1 ], c [ 2 ], twoway ) if time == c [ 4 ]: if c [ 0 ] == \"country\" : if Debug : print ( \"Time = {} . Reopening Border between \" \"[ {} ] and [ {} ]\" . format ( time , c [ 1 ], c [ 2 ]), file = sys . stderr ) self . reopen_border ( c [ 1 ], c [ 2 ], twoway ) if c [ 0 ] == \"location\" : self . reopen_location ( c [ 1 ], twoway ) if c [ 0 ] == \"link\" : self . reopen_link ( c [ 1 ], c [ 2 ], twoway ) evolve ( self ) \u00b6 Summary Source code in flee/flee.py def evolve ( self ): \"\"\" Summary \"\"\" # update level 1, 2 and 3 location scores for l in self . locations : l . time = self . time l . updateLocationScore () for l in self . locations : l . updateNeighbourhoodScore () for l in self . locations : l . updateRegionScore () # update agent locations for a in self . agents : a . evolve () for a in self . agents : a . finish_travel () a . timesteps_since_departure += 1 if SimulationSettings . AgentLogLevel > 0 : write_agents ( self . agents , self . time ) for a in self . agents : a . recent_travel_distance = ( a . recent_travel_distance + ( a . distance_moved_this_timestep / SimulationSettings . MaxMoveSpeed ) ) / 2.0 a . distance_moved_this_timestep = 0 # update link properties if SimulationSettings . CampLogLevel > 0 : self . _aggregate_arrivals () self . time += 1 export_graph ( self , use_ids_instead_of_names = False ) \u00b6 Summary Parameters: Name Type Description Default use_ids_instead_of_names bool Description False Returns: Type Description TYPE Description Source code in flee/flee.py def export_graph ( self , use_ids_instead_of_names = False ): \"\"\" Summary Args: use_ids_instead_of_names (bool, optional): Description Returns: TYPE: Description \"\"\" vertices = [] edges = [] for l in self . locations : vertices += [ l . name ] for p in l . links : edges += [[ l . name , p . endpoint . name , p . distance ]] return vertices , edges get_camp_names ( self ) \u00b6 Summary Returns: Type Description TYPE Description Source code in flee/flee.py def get_camp_names ( self ): \"\"\" Summary Returns: TYPE: Description \"\"\" camp_names = [] for l in self . locations : if l . camp : camp_names += [ l . name ] return camp_names getRankN ( self , i ) \u00b6 Returns whether this process should do a task. Parameters: Name Type Description Default i int Description required Returns: Type Description bool Always returns true, as flee.py is sequential. Source code in flee/flee.py def getRankN ( self , i ): \"\"\" Returns whether this process should do a task. Args: i (int): Description Returns: bool: Always returns true, as flee.py is sequential. \"\"\" return True insertAgent ( self , location ) \u00b6 insert Agent does NOT take from Population. Parameters: Name Type Description Default location Location location object required Source code in flee/flee.py def insertAgent ( self , location ): \"\"\" insert Agent does NOT take from Population. Args: location (Location): location object \"\"\" self . agents . append ( Person ( location )) insertAgents ( self , location , number ) \u00b6 Summary Parameters: Name Type Description Default location TYPE Description required number TYPE Description required Source code in flee/flee.py def insertAgents ( self , location , number ): \"\"\" Summary Args: location (TYPE): Description number (TYPE): Description \"\"\" for i in range ( 0 , number ): self . insertAgent ( location ) linkUp ( self , endpoint1 , endpoint2 , distance = '1.0' , forced_redirection = False ) \u00b6 Creates a link between two endpoint locations Parameters: Name Type Description Default endpoint1 TYPE Description required endpoint2 TYPE Description required distance str Description '1.0' forced_redirection bool Description False Source code in flee/flee.py def linkUp ( self , endpoint1 , endpoint2 , distance = \"1.0\" , forced_redirection = False ): \"\"\" Creates a link between two endpoint locations Args: endpoint1 (TYPE): Description endpoint2 (TYPE): Description distance (str, optional): Description forced_redirection (bool, optional): Description \"\"\" endpoint1_index = - 1 endpoint2_index = - 1 for i in range ( 0 , len ( self . locationNames )): if ( self . locationNames [ i ] == endpoint1 ): endpoint1_index = i if ( self . locationNames [ i ] == endpoint2 ): endpoint2_index = i if endpoint1_index < 0 : print ( \"Diagnostic: Ecosystem.locationNames: \" , self . locationNames ) print ( \"Error: link created to non-existent source: \" , endpoint1 , \" with dest \" , endpoint2 ) sys . exit () if endpoint2_index < 0 : print ( \"Diagnostic: Ecosystem.locationNames: \" , self . locationNames ) print ( \"Error: link created to non-existent destination: \" , endpoint2 , \" with source \" , endpoint1 ) sys . exit () self . locations [ endpoint1_index ] . links . append ( Link ( self . locations [ endpoint1_index ], self . locations [ endpoint2_index ], distance , forced_redirection ) ) self . locations [ endpoint2_index ] . links . append ( Link ( self . locations [ endpoint2_index ], self . locations [ endpoint1_index ], distance ) ) numAgents ( self ) \u00b6 Summary Returns: Type Description TYPE Description Source code in flee/flee.py def numAgents ( self ): \"\"\" Summary Returns: TYPE: Description \"\"\" return len ( self . agents ) pick_conflict_location ( self ) \u00b6 Summary Returns: Type Description TYPE Description Source code in flee/flee.py def pick_conflict_location ( self ): \"\"\" Summary Returns: TYPE: Description \"\"\" # print( # \"Warning: this function is now deprecated as of ruleset 2.0. \" # \"Please use pick_conflict_locations() instead in your scripts.\", # file=sys.stderr # ) return self . pick_conflict_locations ( 1 )[ 0 ] pick_conflict_locations ( self , number = 1 ) \u00b6 Returns a weighted random element from the list of conflict locations. Parameters: Name Type Description Default number int Description 1 Returns: Type Description TYPE returns a number, which is an index in the array of conflict locations. Source code in flee/flee.py def pick_conflict_locations ( self , number = 1 ): \"\"\" Returns a weighted random element from the list of conflict locations. Args: number (int, optional): Description Returns: TYPE: returns a number, which is an index in the array of conflict locations. \"\"\" assert self . conflict_pop > 0 return np . random . choice ( self . conflict_zones , number , p = self . conflict_weights / self . conflict_pop ) printComplete ( self ) \u00b6 Summary Source code in flee/flee.py def printComplete ( self ): \"\"\" Summary \"\"\" print ( \"Time: \" , self . time , \", # of agents: \" , len ( self . agents )) if self . print_location_output : for l in self . locations : print ( \"Location name %s , number of agents %s \" % ( l . name , l . numAgents ), file = sys . stderr ) l . print () printInfo ( self ) \u00b6 Summary Source code in flee/flee.py def printInfo ( self ): \"\"\" Summary \"\"\" print ( \"Time: \" , self . time , \", # of agents: \" , len ( self . agents )) for l in self . locations : print ( l . name , l . numAgents , file = sys . stderr ) refresh_conflict_weights ( self ) \u00b6 This function needs to be called when SimulationSettings.TakeRefugeesFromPopulation is set to True. It will update the weights to reflect the new population numbers. Source code in flee/flee.py def refresh_conflict_weights ( self ): \"\"\" This function needs to be called when SimulationSettings.TakeRefugeesFromPopulation is set to True. It will update the weights to reflect the new population numbers. \"\"\" for i in range ( 0 , len ( self . conflict_zones )): self . conflict_weights [ i ] = self . conflict_zones [ i ] . pop self . conflict_pop = sum ( self . conflict_weights ) remove_conflict_zone ( self , name , change_movechance = True ) \u00b6 Shorthand function to remove a conflict zone from the list. (not used yet) Parameters: Name Type Description Default name TYPE Description required change_movechance bool Description True Source code in flee/flee.py def remove_conflict_zone ( self , name , change_movechance = True ): \"\"\" Shorthand function to remove a conflict zone from the list. (not used yet) Args: name (TYPE): Description change_movechance (bool, optional): Description \"\"\" new_conflict_zones = [] new_conflict_zone_names = [] new_weights = np . array ([]) for i in range ( 0 , len ( self . conflict_zones )): if self . conflict_zones [ i ] . name is not name : new_conflict_zones += [ self . conflict_zones [ i ]] new_conflict_zone_names += [ self . conflict_zone_names [ i ]] new_weights = np . append ( new_weights , [ self . conflict_weights [ i ]]) else : if change_movechance : self . conflict_zones [ i ] . movechance = SimulationSettings . DefaultMoveChance self . conflict_zones [ i ] . conflict = False self . conflict_zones [ i ] . town = True self . conflict_zone_names = new_conflict_zone_names self . conflict_zones = new_conflict_zones self . conflict_weights = new_weights self . conflict_pop = sum ( self . conflict_weights ) remove_link ( self , startpoint , endpoint , twoway = True , close_only = False ) \u00b6 Removes a link between two location names. Parameters: Name Type Description Default startpoint TYPE Description required endpoint TYPE Description required twoway bool if True, also removes link from endpoint to startpoint . True close_only bool if True will instead move the link to the closed_links list of the location, rendering it inactive. False Returns: Type Description TYPE Description Source code in flee/flee.py def remove_link ( self , startpoint , endpoint , twoway = True , close_only = False ): \"\"\" Removes a link between two location names. Args: startpoint (TYPE): Description endpoint (TYPE): Description twoway (bool, optional): if True, also removes link from `endpoint` to `startpoint`. close_only (bool, optional): if `True` will instead move the link to the closed_links list of the location, rendering it inactive. Returns: TYPE: Description \"\"\" if twoway : self . _remove_link_1way ( endpoint , startpoint , close_only ) return self . _remove_link_1way ( startpoint , endpoint , close_only ) reopen_border ( self , source_country , dest_country , twoway = True , Debug = False ) \u00b6 Re-open all links between two countries. Parameters: Name Type Description Default source_country TYPE Description required dest_country TYPE Description required twoway bool if False , only links from source to destination will be closed True Debug bool Description False Source code in flee/flee.py def reopen_border ( self , source_country , dest_country , twoway = True , Debug = False ): \"\"\" Re-open all links between two countries. Args: source_country (TYPE): Description dest_country (TYPE): Description twoway (bool, optional): if `False`, only links from source to destination will be closed Debug (bool, optional): Description \"\"\" self . _change_border_1way ( source_country , dest_country , mode = \"reopen\" , Debug = Debug ) if twoway : self . _change_border_1way ( dest_country , source_country , mode = \"reopen\" , Debug = Debug ) reopen_link ( self , startpoint , endpoint , twoway = True ) \u00b6 Reopens a previously closed link between two location names. Parameters: Name Type Description Default startpoint TYPE Description required endpoint TYPE Description required twoway bool if True , also removes link from endpoint to startpoint . True Returns: Type Description TYPE Description Source code in flee/flee.py def reopen_link ( self , startpoint , endpoint , twoway = True ): \"\"\" Reopens a previously closed link between two location names. Args: startpoint (TYPE): Description endpoint (TYPE): Description twoway (bool, optional): if `True`, also removes link from `endpoint` to `startpoint`. Returns: TYPE: Description \"\"\" if twoway : self . _reopen_link_1way ( endpoint , startpoint ) return self . _reopen_link_1way ( startpoint , endpoint ) reopen_location ( self , location_name , twoway = True , Debug = False ) \u00b6 Reopen in- and outgoing links for a location. Parameters: Name Type Description Default location_name TYPE Description required twoway bool Description True Debug bool Description False Source code in flee/flee.py def reopen_location ( self , location_name , twoway = True , Debug = False ): \"\"\" Reopen in- and outgoing links for a location. Args: location_name (TYPE): Description twoway (bool, optional): Description Debug (bool, optional): Description \"\"\" if twoway : self . _change_location_1way ( location_name , mode = \"reopen\" , direction = \"both\" , Debug = Debug ) else : self . _change_location_1way ( location_name , mode = \"reopen\" , direction = \"in\" , Debug = Debug ) selection: docstring_style: google # this is the default inherited_members: True members: :docstring:","title":"Ecosystem"},{"location":"code_reference/flee_ecosystem/#ecosystem-class","text":"a base class for Ecosystem object Attributes: Name Type Description agents list Description closures list Description conflict_pop int Description conflict_weights TYPE Description conflict_zone_names list Description conflict_zones list Description locationNames list Description locations list Description num_arrivals list Description print_location_output bool Description time int Description travel_durations list Description","title":"Ecosystem class"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem-methods","text":"","title":"Methods"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.add_agents_to_conflict_zones","text":"Add a group of agents, distributed across conflict zones. Parameters: Name Type Description Default number TYPE Description required Source code in flee/flee.py def add_agents_to_conflict_zones ( self , number ): \"\"\" Add a group of agents, distributed across conflict zones. Args: number (TYPE): Description \"\"\" cl = self . pick_conflict_locations ( number ) for i in range ( 0 , number ): self . addAgent ( cl [ i ])","title":"add_agents_to_conflict_zones()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.add_conflict_zone","text":"Adds a conflict zone. Default weight is equal to population of the location. Parameters: Name Type Description Default name TYPE Description required change_movechance bool Description True Returns: Type Description TYPE Description Source code in flee/flee.py def add_conflict_zone ( self , name , change_movechance = True ): \"\"\" Adds a conflict zone. Default weight is equal to population of the location. Args: name (TYPE): Description change_movechance (bool, optional): Description Returns: TYPE: Description \"\"\" for i in range ( 0 , len ( self . locationNames )): if self . locationNames [ i ] == name : if name not in self . conflict_zone_names : if change_movechance : self . locations [ i ] . movechance = ( SimulationSettings . ConflictMoveChance ) self . locations [ i ] . conflict = True self . locations [ i ] . town = False self . conflict_zone_names += [ name ] self . conflict_zones += [ self . locations [ i ]] self . conflict_weights = np . append ( self . conflict_weights , [ self . locations [ i ] . pop ]) self . conflict_pop = sum ( self . conflict_weights ) if SimulationSettings . InitLogLevel > 0 : print ( \"Added conflict zone:\" , name , \", pop. \" , self . locations [ i ] . pop ) print ( \"New total pop. in conflict zones: \" , self . conflict_pop ) return print ( \"Diagnostic: self.locationNames: \" , self . locationNames ) print ( \"ERROR in flee.add_conflict_zone: location with name [ {} ] appears\" \" not to exist in the FLEE ecosystem \" \"(see diagnostic above).\" . format ( name ) )","title":"add_conflict_zone()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.addAgent","text":"Add an agent to the location object Parameters: Name Type Description Default location Link location object required Source code in flee/flee.py def addAgent ( self , location ): \"\"\" Add an agent to the location object Args: location (Link): location object \"\"\" if SimulationSettings . TakeRefugeesFromPopulation : if location . conflict : if location . pop > 0 : location . pop -= 1 location . numAgentsSpawned += 1 else : print ( \"ERROR: Number of agents in the simulation is \" \"larger than the combined population of the conflict\" \" zones. Please amend locations.csv.\" ) location . print () assert location . pop > 1 self . agents . append ( Person ( location ))","title":"addAgent()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.addLocation","text":"Add a location to the ABM network graph Parameters: Name Type Description Default name TYPE Description required x str Description '0.0' y str Description '0.0' movechance TYPE Description 0.3 capacity TYPE Description -1 pop int Description 0 foreign bool Description False country str Description 'unknown' Returns: Type Description TYPE location object (Link class) Source code in flee/flee.py def addLocation ( self , name , x = \"0.0\" , y = \"0.0\" , movechance = SimulationSettings . DefaultMoveChance , capacity =- 1 , pop = 0 , foreign = False , country = \"unknown\" ): \"\"\" Add a location to the ABM network graph Args: name (TYPE): Description x (str, optional): Description y (str, optional): Description movechance (TYPE, optional): Description capacity (TYPE, optional): Description pop (int, optional): Description foreign (bool, optional): Description country (str, optional): Description Returns: TYPE: location object (Link class) \"\"\" l = Location ( name , x , y , movechance , capacity , pop , foreign , country ) if SimulationSettings . InitLogLevel > 0 and self . print_location_output : print ( \"Location:\" , name , x , y , l . movechance , capacity , \", pop. \" , pop , foreign ) self . locations . append ( l ) self . locationNames . append ( l . name ) return l","title":"addLocation()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.clearLocationsFromAgents","text":"Remove all agents from a list of locations by name. Useful for couplings to other simulation codes. Parameters: Name Type Description Default location_names TYPE Description required Source code in flee/flee.py def clearLocationsFromAgents ( self , location_names ): \"\"\" Remove all agents from a list of locations by name. Useful for couplings to other simulation codes. Args: location_names (TYPE): Description \"\"\" new_agents = [] for i in range ( 0 , len ( self . agents )): if self . agents [ i ] . location . name not in location_names : new_agents += agents [ i ] # agent is preserved in ecosystem else : # agent is removed from the ecosystem and number of agents # drops by one. self . agents [ i ] . location . DecrementNumAgents () self . agents = new_agents","title":"clearLocationsFromAgents()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.close_border","text":"Close all links between two countries. Parameters: Name Type Description Default source_country TYPE Description required dest_country TYPE Description required twoway bool if False , only links from source to destination will be closed True Debug bool Description False Source code in flee/flee.py def close_border ( self , source_country , dest_country , twoway = True , Debug = False ): \"\"\" Close all links between two countries. Args: source_country (TYPE): Description dest_country (TYPE): Description twoway (bool, optional): if `False`, only links from source to destination will be closed Debug (bool, optional): Description \"\"\" self . _change_border_1way ( source_country , dest_country , mode = \"close\" , Debug = Debug ) if twoway : self . _change_border_1way ( dest_country , source_country , mode = \"close\" , Debug = Debug )","title":"close_border()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.close_link","text":"Shorthand call for remove_link, only moving the link to the closed list. Parameters: Name Type Description Default startpoint TYPE Description required endpoint TYPE Description required twoway bool Description True Returns: Type Description TYPE Description Source code in flee/flee.py def close_link ( self , startpoint , endpoint , twoway = True ): \"\"\" Shorthand call for remove_link, only moving the link to the closed list. Args: startpoint (TYPE): Description endpoint (TYPE): Description twoway (bool, optional): Description Returns: TYPE: Description \"\"\" return self . remove_link ( startpoint , endpoint , twoway = twoway , close_only = True )","title":"close_link()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.close_location","text":"Close in- and outgoing links for a location. Parameters: Name Type Description Default location_name TYPE Description required twoway bool Description True Debug bool Description False Returns: Type Description TYPE Description Source code in flee/flee.py def close_location ( self , location_name , twoway = True , Debug = False ): \"\"\" Close in- and outgoing links for a location. Args: location_name (TYPE): Description twoway (bool, optional): Description Debug (bool, optional): Description Returns: TYPE: Description \"\"\" if twoway : return self . _change_location_1way ( location_name , mode = \"close\" , direction = \"both\" , Debug = Debug ) else : return self . _change_location_1way ( location_name , mode = \"close\" , direction = \"in\" , Debug = Debug )","title":"close_location()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.enact_border_closures","text":"Summary Parameters: Name Type Description Default time TYPE Description required twoway bool Description True Debug bool Description False Source code in flee/flee.py def enact_border_closures ( self , time , twoway = True , Debug = False ): \"\"\" Summary Args: time (TYPE): Description twoway (bool, optional): Description Debug (bool, optional): Description \"\"\" # print(\"Enact border closures: \", self.closures) if len ( self . closures ) > 0 : for c in self . closures : if time == c [ 3 ]: if c [ 0 ] == \"country\" : if Debug : print ( \"Time = {} . Closing Border between \" \"[ {} ] and [ {} ]\" . format ( time , c [ 1 ], c [ 2 ]), file = sys . stderr ) self . close_border ( c [ 1 ], c [ 2 ], twoway ) if c [ 0 ] == \"location\" : self . close_location ( c [ 1 ], twoway ) if c [ 0 ] == \"link\" : self . close_link ( c [ 1 ], c [ 2 ], twoway ) if time == c [ 4 ]: if c [ 0 ] == \"country\" : if Debug : print ( \"Time = {} . Reopening Border between \" \"[ {} ] and [ {} ]\" . format ( time , c [ 1 ], c [ 2 ]), file = sys . stderr ) self . reopen_border ( c [ 1 ], c [ 2 ], twoway ) if c [ 0 ] == \"location\" : self . reopen_location ( c [ 1 ], twoway ) if c [ 0 ] == \"link\" : self . reopen_link ( c [ 1 ], c [ 2 ], twoway )","title":"enact_border_closures()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.evolve","text":"Summary Source code in flee/flee.py def evolve ( self ): \"\"\" Summary \"\"\" # update level 1, 2 and 3 location scores for l in self . locations : l . time = self . time l . updateLocationScore () for l in self . locations : l . updateNeighbourhoodScore () for l in self . locations : l . updateRegionScore () # update agent locations for a in self . agents : a . evolve () for a in self . agents : a . finish_travel () a . timesteps_since_departure += 1 if SimulationSettings . AgentLogLevel > 0 : write_agents ( self . agents , self . time ) for a in self . agents : a . recent_travel_distance = ( a . recent_travel_distance + ( a . distance_moved_this_timestep / SimulationSettings . MaxMoveSpeed ) ) / 2.0 a . distance_moved_this_timestep = 0 # update link properties if SimulationSettings . CampLogLevel > 0 : self . _aggregate_arrivals () self . time += 1","title":"evolve()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.export_graph","text":"Summary Parameters: Name Type Description Default use_ids_instead_of_names bool Description False Returns: Type Description TYPE Description Source code in flee/flee.py def export_graph ( self , use_ids_instead_of_names = False ): \"\"\" Summary Args: use_ids_instead_of_names (bool, optional): Description Returns: TYPE: Description \"\"\" vertices = [] edges = [] for l in self . locations : vertices += [ l . name ] for p in l . links : edges += [[ l . name , p . endpoint . name , p . distance ]] return vertices , edges","title":"export_graph()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.get_camp_names","text":"Summary Returns: Type Description TYPE Description Source code in flee/flee.py def get_camp_names ( self ): \"\"\" Summary Returns: TYPE: Description \"\"\" camp_names = [] for l in self . locations : if l . camp : camp_names += [ l . name ] return camp_names","title":"get_camp_names()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.getRankN","text":"Returns whether this process should do a task. Parameters: Name Type Description Default i int Description required Returns: Type Description bool Always returns true, as flee.py is sequential. Source code in flee/flee.py def getRankN ( self , i ): \"\"\" Returns whether this process should do a task. Args: i (int): Description Returns: bool: Always returns true, as flee.py is sequential. \"\"\" return True","title":"getRankN()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.insertAgent","text":"insert Agent does NOT take from Population. Parameters: Name Type Description Default location Location location object required Source code in flee/flee.py def insertAgent ( self , location ): \"\"\" insert Agent does NOT take from Population. Args: location (Location): location object \"\"\" self . agents . append ( Person ( location ))","title":"insertAgent()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.insertAgents","text":"Summary Parameters: Name Type Description Default location TYPE Description required number TYPE Description required Source code in flee/flee.py def insertAgents ( self , location , number ): \"\"\" Summary Args: location (TYPE): Description number (TYPE): Description \"\"\" for i in range ( 0 , number ): self . insertAgent ( location )","title":"insertAgents()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.linkUp","text":"Creates a link between two endpoint locations Parameters: Name Type Description Default endpoint1 TYPE Description required endpoint2 TYPE Description required distance str Description '1.0' forced_redirection bool Description False Source code in flee/flee.py def linkUp ( self , endpoint1 , endpoint2 , distance = \"1.0\" , forced_redirection = False ): \"\"\" Creates a link between two endpoint locations Args: endpoint1 (TYPE): Description endpoint2 (TYPE): Description distance (str, optional): Description forced_redirection (bool, optional): Description \"\"\" endpoint1_index = - 1 endpoint2_index = - 1 for i in range ( 0 , len ( self . locationNames )): if ( self . locationNames [ i ] == endpoint1 ): endpoint1_index = i if ( self . locationNames [ i ] == endpoint2 ): endpoint2_index = i if endpoint1_index < 0 : print ( \"Diagnostic: Ecosystem.locationNames: \" , self . locationNames ) print ( \"Error: link created to non-existent source: \" , endpoint1 , \" with dest \" , endpoint2 ) sys . exit () if endpoint2_index < 0 : print ( \"Diagnostic: Ecosystem.locationNames: \" , self . locationNames ) print ( \"Error: link created to non-existent destination: \" , endpoint2 , \" with source \" , endpoint1 ) sys . exit () self . locations [ endpoint1_index ] . links . append ( Link ( self . locations [ endpoint1_index ], self . locations [ endpoint2_index ], distance , forced_redirection ) ) self . locations [ endpoint2_index ] . links . append ( Link ( self . locations [ endpoint2_index ], self . locations [ endpoint1_index ], distance ) )","title":"linkUp()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.numAgents","text":"Summary Returns: Type Description TYPE Description Source code in flee/flee.py def numAgents ( self ): \"\"\" Summary Returns: TYPE: Description \"\"\" return len ( self . agents )","title":"numAgents()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.pick_conflict_location","text":"Summary Returns: Type Description TYPE Description Source code in flee/flee.py def pick_conflict_location ( self ): \"\"\" Summary Returns: TYPE: Description \"\"\" # print( # \"Warning: this function is now deprecated as of ruleset 2.0. \" # \"Please use pick_conflict_locations() instead in your scripts.\", # file=sys.stderr # ) return self . pick_conflict_locations ( 1 )[ 0 ]","title":"pick_conflict_location()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.pick_conflict_locations","text":"Returns a weighted random element from the list of conflict locations. Parameters: Name Type Description Default number int Description 1 Returns: Type Description TYPE returns a number, which is an index in the array of conflict locations. Source code in flee/flee.py def pick_conflict_locations ( self , number = 1 ): \"\"\" Returns a weighted random element from the list of conflict locations. Args: number (int, optional): Description Returns: TYPE: returns a number, which is an index in the array of conflict locations. \"\"\" assert self . conflict_pop > 0 return np . random . choice ( self . conflict_zones , number , p = self . conflict_weights / self . conflict_pop )","title":"pick_conflict_locations()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.printComplete","text":"Summary Source code in flee/flee.py def printComplete ( self ): \"\"\" Summary \"\"\" print ( \"Time: \" , self . time , \", # of agents: \" , len ( self . agents )) if self . print_location_output : for l in self . locations : print ( \"Location name %s , number of agents %s \" % ( l . name , l . numAgents ), file = sys . stderr ) l . print ()","title":"printComplete()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.printInfo","text":"Summary Source code in flee/flee.py def printInfo ( self ): \"\"\" Summary \"\"\" print ( \"Time: \" , self . time , \", # of agents: \" , len ( self . agents )) for l in self . locations : print ( l . name , l . numAgents , file = sys . stderr )","title":"printInfo()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.refresh_conflict_weights","text":"This function needs to be called when SimulationSettings.TakeRefugeesFromPopulation is set to True. It will update the weights to reflect the new population numbers. Source code in flee/flee.py def refresh_conflict_weights ( self ): \"\"\" This function needs to be called when SimulationSettings.TakeRefugeesFromPopulation is set to True. It will update the weights to reflect the new population numbers. \"\"\" for i in range ( 0 , len ( self . conflict_zones )): self . conflict_weights [ i ] = self . conflict_zones [ i ] . pop self . conflict_pop = sum ( self . conflict_weights )","title":"refresh_conflict_weights()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.remove_conflict_zone","text":"Shorthand function to remove a conflict zone from the list. (not used yet) Parameters: Name Type Description Default name TYPE Description required change_movechance bool Description True Source code in flee/flee.py def remove_conflict_zone ( self , name , change_movechance = True ): \"\"\" Shorthand function to remove a conflict zone from the list. (not used yet) Args: name (TYPE): Description change_movechance (bool, optional): Description \"\"\" new_conflict_zones = [] new_conflict_zone_names = [] new_weights = np . array ([]) for i in range ( 0 , len ( self . conflict_zones )): if self . conflict_zones [ i ] . name is not name : new_conflict_zones += [ self . conflict_zones [ i ]] new_conflict_zone_names += [ self . conflict_zone_names [ i ]] new_weights = np . append ( new_weights , [ self . conflict_weights [ i ]]) else : if change_movechance : self . conflict_zones [ i ] . movechance = SimulationSettings . DefaultMoveChance self . conflict_zones [ i ] . conflict = False self . conflict_zones [ i ] . town = True self . conflict_zone_names = new_conflict_zone_names self . conflict_zones = new_conflict_zones self . conflict_weights = new_weights self . conflict_pop = sum ( self . conflict_weights )","title":"remove_conflict_zone()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.remove_link","text":"Removes a link between two location names. Parameters: Name Type Description Default startpoint TYPE Description required endpoint TYPE Description required twoway bool if True, also removes link from endpoint to startpoint . True close_only bool if True will instead move the link to the closed_links list of the location, rendering it inactive. False Returns: Type Description TYPE Description Source code in flee/flee.py def remove_link ( self , startpoint , endpoint , twoway = True , close_only = False ): \"\"\" Removes a link between two location names. Args: startpoint (TYPE): Description endpoint (TYPE): Description twoway (bool, optional): if True, also removes link from `endpoint` to `startpoint`. close_only (bool, optional): if `True` will instead move the link to the closed_links list of the location, rendering it inactive. Returns: TYPE: Description \"\"\" if twoway : self . _remove_link_1way ( endpoint , startpoint , close_only ) return self . _remove_link_1way ( startpoint , endpoint , close_only )","title":"remove_link()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.reopen_border","text":"Re-open all links between two countries. Parameters: Name Type Description Default source_country TYPE Description required dest_country TYPE Description required twoway bool if False , only links from source to destination will be closed True Debug bool Description False Source code in flee/flee.py def reopen_border ( self , source_country , dest_country , twoway = True , Debug = False ): \"\"\" Re-open all links between two countries. Args: source_country (TYPE): Description dest_country (TYPE): Description twoway (bool, optional): if `False`, only links from source to destination will be closed Debug (bool, optional): Description \"\"\" self . _change_border_1way ( source_country , dest_country , mode = \"reopen\" , Debug = Debug ) if twoway : self . _change_border_1way ( dest_country , source_country , mode = \"reopen\" , Debug = Debug )","title":"reopen_border()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.reopen_link","text":"Reopens a previously closed link between two location names. Parameters: Name Type Description Default startpoint TYPE Description required endpoint TYPE Description required twoway bool if True , also removes link from endpoint to startpoint . True Returns: Type Description TYPE Description Source code in flee/flee.py def reopen_link ( self , startpoint , endpoint , twoway = True ): \"\"\" Reopens a previously closed link between two location names. Args: startpoint (TYPE): Description endpoint (TYPE): Description twoway (bool, optional): if `True`, also removes link from `endpoint` to `startpoint`. Returns: TYPE: Description \"\"\" if twoway : self . _reopen_link_1way ( endpoint , startpoint ) return self . _reopen_link_1way ( startpoint , endpoint )","title":"reopen_link()"},{"location":"code_reference/flee_ecosystem/#flee.flee.Ecosystem.reopen_location","text":"Reopen in- and outgoing links for a location. Parameters: Name Type Description Default location_name TYPE Description required twoway bool Description True Debug bool Description False Source code in flee/flee.py def reopen_location ( self , location_name , twoway = True , Debug = False ): \"\"\" Reopen in- and outgoing links for a location. Args: location_name (TYPE): Description twoway (bool, optional): Description Debug (bool, optional): Description \"\"\" if twoway : self . _change_location_1way ( location_name , mode = \"reopen\" , direction = \"both\" , Debug = Debug ) else : self . _change_location_1way ( location_name , mode = \"reopen\" , direction = \"in\" , Debug = Debug ) selection: docstring_style: google # this is the default inherited_members: True members: :docstring:","title":"reopen_location()"},{"location":"code_reference/flee_location/","text":"Location class \u00b6 The base class for the Location object Attributes: Name Type Description camp bool Description capacity TYPE Description closed_links list Description conflict bool Description country TYPE Description foreign bool Description forward bool Description incoming_journey_lengths list Description links list Description LocationScore float Description marker bool Description movechance float Description name TYPE Description NeighbourhoodScore float Description numAgents int Description numAgentsOnRank int Description numAgentsSpawned int Description pop TYPE Description RegionScore float Description scores TYPE Description time int Description town bool Description x TYPE Description y TYPE Description Methods \u00b6 CalculateResidualWeightingFactor ( self , residual , cap_limit , nearly_full_occ ) \u00b6 Calculate the residual weighting factor, when pop is between 0.9 and 1.0 of capacity (with default settings). Note Weight should be 1.0 at 0.9, and 0.0 at 1.0 capacity level. Tip Asserts are added to prevent corruption of simulation results in case this function misbehaves. Parameters: Name Type Description Default residual float the residual weighting factor required cap_limit int Description required nearly_full_occ float Description required Returns: Type Description TYPE Description Source code in flee/flee.py def CalculateResidualWeightingFactor ( self , residual , cap_limit , nearly_full_occ ): \"\"\" Calculate the residual weighting factor, when pop is between 0.9 and 1.0 of capacity (with default settings). !!! note Weight should be 1.0 at 0.9, and 0.0 at 1.0 capacity level. !!! tip Asserts are added to prevent corruption of simulation results in case this function misbehaves. Args: residual (float): the residual weighting factor cap_limit (int): Description nearly_full_occ (float): Description Returns: TYPE: Description \"\"\" weight = 1.0 - ( residual / ( cap_limit * ( 1.0 - nearly_full_occ ))) assert ( weight >= 0.0 ) assert ( weight <= 1.0 ) return weight DecrementNumAgents ( self ) \u00b6 Summary Source code in flee/flee.py def DecrementNumAgents ( self ): \"\"\" Summary \"\"\" self . numAgents -= 1 getCapMultiplier ( self , numOnLink ) \u00b6 Checks whether a given location has reached full capacity or is close to it. Parameters: Name Type Description Default numOnLink TYPE Description required Returns: Type Description float 1.0 if occupancy < nearly_full_occ (0.9). 0.0 if occupancy >= 1.0. a value in between for intermediate values Source code in flee/flee.py def getCapMultiplier ( self , numOnLink ): \"\"\" Checks whether a given location has reached full capacity or is close to it. Args: numOnLink (TYPE): Description Returns: float: - 1.0 if occupancy < nearly_full_occ (0.9). - 0.0 if occupancy >= 1.0. - a value in between for intermediate values \"\"\" nearly_full_occ = 0.9 # occupancy rate to be considered nearly full. # full occupancy limit (should be equal to self.capacity). cap_limit = self . capacity * SimulationSettings . CapacityBuffer if self . capacity < 0 : return 1.0 elif self . numAgents <= nearly_full_occ * cap_limit : return 1.0 elif self . numAgents >= 1.0 * cap_limit : return 0.0 # should be a number equal in range [0 to 0.1*self.numAgents]. residual = self . numAgents - ( nearly_full_occ * cap_limit ) return self . CalculateResidualWeightingFactor ( residual , cap_limit , nearly_full_occ ) getScores ( self , index ) \u00b6 Summary Parameters: Name Type Description Default index TYPE Description required Returns: Type Description TYPE Description Source code in flee/flee.py def getScores ( self , index ): \"\"\" Summary Args: index (TYPE): Description Returns: TYPE: Description \"\"\" return self . scores [ index ] IncrementNumAgents ( self ) \u00b6 Summary Source code in flee/flee.py def IncrementNumAgents ( self ): \"\"\" Summary \"\"\" self . numAgents += 1 SetCampMoveChance ( self ) \u00b6 Modify move chance to the default value set for camps. Source code in flee/flee.py def SetCampMoveChance ( self ): \"\"\" Modify move chance to the default value set for camps. \"\"\" self . movechance = SimulationSettings . CampMoveChance SetConflictMoveChance ( self ) \u00b6 Modify move chance to the default value set for conflict regions. Source code in flee/flee.py def SetConflictMoveChance ( self ): \"\"\" Modify move chance to the default value set for conflict regions. \"\"\" self . movechance = SimulationSettings . ConflictMoveChance setScore ( self , index , value ) \u00b6 Summary Parameters: Name Type Description Default index TYPE Description required value TYPE Description required Source code in flee/flee.py def setScore ( self , index , value ): \"\"\" Summary Args: index (TYPE): Description value (TYPE): Description \"\"\" self . scores [ index ] = value updateLocationScore ( self ) \u00b6 Attractiveness of the local point, based on local point information only. Source code in flee/flee.py def updateLocationScore ( self ): \"\"\" Attractiveness of the local point, based on local point information only. \"\"\" if self . foreign or self . camp : # * max(1.0,SimulationSettings.AwarenessLevel) self . LocationScore = SimulationSettings . CampWeight elif self . conflict : # * max(1.0,SimulationSettings.AwarenessLevel) self . LocationScore = SimulationSettings . ConflictWeight else : self . LocationScore = 1.0 self . setScore ( 0 , 1.0 ) self . setScore ( 1 , self . LocationScore ) # print(self.name,self.camp,self.foreign,self.LocationScore) updateNeighbourhoodScore ( self ) \u00b6 Attractiveness of the local point, based on information from local and adjacent points, weighted by link length. Source code in flee/flee.py def updateNeighbourhoodScore ( self ): \"\"\" Attractiveness of the local point, based on information from local and adjacent points, weighted by link length. \"\"\" # No links connected or a Camp? Use LocationScore. if len ( self . links ) == 0 or self . camp : self . NeighbourhoodScore = self . LocationScore return self . NeighbourhoodScore = 0.0 total_link_weight = 0.0 for i in self . links : self . NeighbourhoodScore += i . endpoint . LocationScore / \\ float ( i . distance ) total_link_weight += 1.0 / float ( i . distance ) self . NeighbourhoodScore /= total_link_weight self . setScore ( 2 , self . NeighbourhoodScore ) updateRegionScore ( self ) \u00b6 Attractiveness of the local point, based on neighbourhood information from local and adjacent points, weighted by link length. Source code in flee/flee.py def updateRegionScore ( self ): \"\"\" Attractiveness of the local point, based on neighbourhood information from local and adjacent points, weighted by link length. \"\"\" # No links connected or a Camp? Use LocationScore. if len ( self . links ) == 0 or self . camp : self . RegionScore = self . LocationScore return self . RegionScore = 0.0 total_link_weight = 0.0 for i in self . links : self . RegionScore += i . endpoint . NeighbourhoodScore / \\ float ( i . distance ) total_link_weight += 1.0 / float ( i . distance ) self . RegionScore /= total_link_weight self . setScore ( 3 , self . RegionScore ) selection: docstring_style: google # this is the default inherited_members: True members: :docstring:","title":"Location"},{"location":"code_reference/flee_location/#location-class","text":"The base class for the Location object Attributes: Name Type Description camp bool Description capacity TYPE Description closed_links list Description conflict bool Description country TYPE Description foreign bool Description forward bool Description incoming_journey_lengths list Description links list Description LocationScore float Description marker bool Description movechance float Description name TYPE Description NeighbourhoodScore float Description numAgents int Description numAgentsOnRank int Description numAgentsSpawned int Description pop TYPE Description RegionScore float Description scores TYPE Description time int Description town bool Description x TYPE Description y TYPE Description","title":"Location class"},{"location":"code_reference/flee_location/#flee.flee.Location-methods","text":"","title":"Methods"},{"location":"code_reference/flee_location/#flee.flee.Location.CalculateResidualWeightingFactor","text":"Calculate the residual weighting factor, when pop is between 0.9 and 1.0 of capacity (with default settings). Note Weight should be 1.0 at 0.9, and 0.0 at 1.0 capacity level. Tip Asserts are added to prevent corruption of simulation results in case this function misbehaves. Parameters: Name Type Description Default residual float the residual weighting factor required cap_limit int Description required nearly_full_occ float Description required Returns: Type Description TYPE Description Source code in flee/flee.py def CalculateResidualWeightingFactor ( self , residual , cap_limit , nearly_full_occ ): \"\"\" Calculate the residual weighting factor, when pop is between 0.9 and 1.0 of capacity (with default settings). !!! note Weight should be 1.0 at 0.9, and 0.0 at 1.0 capacity level. !!! tip Asserts are added to prevent corruption of simulation results in case this function misbehaves. Args: residual (float): the residual weighting factor cap_limit (int): Description nearly_full_occ (float): Description Returns: TYPE: Description \"\"\" weight = 1.0 - ( residual / ( cap_limit * ( 1.0 - nearly_full_occ ))) assert ( weight >= 0.0 ) assert ( weight <= 1.0 ) return weight","title":"CalculateResidualWeightingFactor()"},{"location":"code_reference/flee_location/#flee.flee.Location.DecrementNumAgents","text":"Summary Source code in flee/flee.py def DecrementNumAgents ( self ): \"\"\" Summary \"\"\" self . numAgents -= 1","title":"DecrementNumAgents()"},{"location":"code_reference/flee_location/#flee.flee.Location.getCapMultiplier","text":"Checks whether a given location has reached full capacity or is close to it. Parameters: Name Type Description Default numOnLink TYPE Description required Returns: Type Description float 1.0 if occupancy < nearly_full_occ (0.9). 0.0 if occupancy >= 1.0. a value in between for intermediate values Source code in flee/flee.py def getCapMultiplier ( self , numOnLink ): \"\"\" Checks whether a given location has reached full capacity or is close to it. Args: numOnLink (TYPE): Description Returns: float: - 1.0 if occupancy < nearly_full_occ (0.9). - 0.0 if occupancy >= 1.0. - a value in between for intermediate values \"\"\" nearly_full_occ = 0.9 # occupancy rate to be considered nearly full. # full occupancy limit (should be equal to self.capacity). cap_limit = self . capacity * SimulationSettings . CapacityBuffer if self . capacity < 0 : return 1.0 elif self . numAgents <= nearly_full_occ * cap_limit : return 1.0 elif self . numAgents >= 1.0 * cap_limit : return 0.0 # should be a number equal in range [0 to 0.1*self.numAgents]. residual = self . numAgents - ( nearly_full_occ * cap_limit ) return self . CalculateResidualWeightingFactor ( residual , cap_limit , nearly_full_occ )","title":"getCapMultiplier()"},{"location":"code_reference/flee_location/#flee.flee.Location.getScores","text":"Summary Parameters: Name Type Description Default index TYPE Description required Returns: Type Description TYPE Description Source code in flee/flee.py def getScores ( self , index ): \"\"\" Summary Args: index (TYPE): Description Returns: TYPE: Description \"\"\" return self . scores [ index ]","title":"getScores()"},{"location":"code_reference/flee_location/#flee.flee.Location.IncrementNumAgents","text":"Summary Source code in flee/flee.py def IncrementNumAgents ( self ): \"\"\" Summary \"\"\" self . numAgents += 1","title":"IncrementNumAgents()"},{"location":"code_reference/flee_location/#flee.flee.Location.SetCampMoveChance","text":"Modify move chance to the default value set for camps. Source code in flee/flee.py def SetCampMoveChance ( self ): \"\"\" Modify move chance to the default value set for camps. \"\"\" self . movechance = SimulationSettings . CampMoveChance","title":"SetCampMoveChance()"},{"location":"code_reference/flee_location/#flee.flee.Location.SetConflictMoveChance","text":"Modify move chance to the default value set for conflict regions. Source code in flee/flee.py def SetConflictMoveChance ( self ): \"\"\" Modify move chance to the default value set for conflict regions. \"\"\" self . movechance = SimulationSettings . ConflictMoveChance","title":"SetConflictMoveChance()"},{"location":"code_reference/flee_location/#flee.flee.Location.setScore","text":"Summary Parameters: Name Type Description Default index TYPE Description required value TYPE Description required Source code in flee/flee.py def setScore ( self , index , value ): \"\"\" Summary Args: index (TYPE): Description value (TYPE): Description \"\"\" self . scores [ index ] = value","title":"setScore()"},{"location":"code_reference/flee_location/#flee.flee.Location.updateLocationScore","text":"Attractiveness of the local point, based on local point information only. Source code in flee/flee.py def updateLocationScore ( self ): \"\"\" Attractiveness of the local point, based on local point information only. \"\"\" if self . foreign or self . camp : # * max(1.0,SimulationSettings.AwarenessLevel) self . LocationScore = SimulationSettings . CampWeight elif self . conflict : # * max(1.0,SimulationSettings.AwarenessLevel) self . LocationScore = SimulationSettings . ConflictWeight else : self . LocationScore = 1.0 self . setScore ( 0 , 1.0 ) self . setScore ( 1 , self . LocationScore ) # print(self.name,self.camp,self.foreign,self.LocationScore)","title":"updateLocationScore()"},{"location":"code_reference/flee_location/#flee.flee.Location.updateNeighbourhoodScore","text":"Attractiveness of the local point, based on information from local and adjacent points, weighted by link length. Source code in flee/flee.py def updateNeighbourhoodScore ( self ): \"\"\" Attractiveness of the local point, based on information from local and adjacent points, weighted by link length. \"\"\" # No links connected or a Camp? Use LocationScore. if len ( self . links ) == 0 or self . camp : self . NeighbourhoodScore = self . LocationScore return self . NeighbourhoodScore = 0.0 total_link_weight = 0.0 for i in self . links : self . NeighbourhoodScore += i . endpoint . LocationScore / \\ float ( i . distance ) total_link_weight += 1.0 / float ( i . distance ) self . NeighbourhoodScore /= total_link_weight self . setScore ( 2 , self . NeighbourhoodScore )","title":"updateNeighbourhoodScore()"},{"location":"code_reference/flee_location/#flee.flee.Location.updateRegionScore","text":"Attractiveness of the local point, based on neighbourhood information from local and adjacent points, weighted by link length. Source code in flee/flee.py def updateRegionScore ( self ): \"\"\" Attractiveness of the local point, based on neighbourhood information from local and adjacent points, weighted by link length. \"\"\" # No links connected or a Camp? Use LocationScore. if len ( self . links ) == 0 or self . camp : self . RegionScore = self . LocationScore return self . RegionScore = 0.0 total_link_weight = 0.0 for i in self . links : self . RegionScore += i . endpoint . NeighbourhoodScore / \\ float ( i . distance ) total_link_weight += 1.0 / float ( i . distance ) self . RegionScore /= total_link_weight self . setScore ( 3 , self . RegionScore ) selection: docstring_style: google # this is the default inherited_members: True members: :docstring:","title":"updateRegionScore()"},{"location":"code_reference/flee_person/","text":"Person class \u00b6 The base class for the agent object Attributes: Name Type Description distance_moved_this_timestep float Description distance_travelled int Description distance_travelled_on_link int Description home_location TYPE Description location TYPE Description places_travelled int Description recent_travel_distance float Description timesteps_since_departure int Description travelling bool Description Methods \u00b6 calculateLinkWeight ( self , link , prior_distance , origin_names , step , debug = False ) \u00b6 Calculates Link Weights recursively based on awareness level. Loops are avoided. Parameters: Name Type Description Default link TYPE Link class obj required prior_distance TYPE Description required origin_names TYPE Description required step TYPE Description required debug bool Description False Returns: Type Description TYPE Description Source code in flee/flee.py def calculateLinkWeight ( self , link , prior_distance , origin_names , step , debug = False ): \"\"\" Calculates Link Weights recursively based on awareness level. Loops are avoided. Args: link (TYPE): Link class obj prior_distance (TYPE): Description origin_names (TYPE): Description step (TYPE): Description debug (bool, optional): Description Returns: TYPE: Description \"\"\" weight = float ( self . getEndPointScore ( link ) / float ( SimulationSettings . Softening + link . distance + prior_distance ) ) * link . endpoint . getCapMultiplier ( link . numAgents ) if debug : print ( \"step {} , dest {} , dist {} , prior_dist {} , \" \"score {} , weight {} \" . format ( step , link . endpoint . name , link . distance , prior_distance , self . getEndPointScore ( link ), weight ) ) if SimulationSettings . AwarenessLevel > step : # Traverse the tree one step further. for k , e in enumerate ( link . endpoint . links ): if e . endpoint . name in origin_names : # Link points back to an origin, so ignore. pass else : weight = max ( weight , self . calculateLinkWeight ( e , prior_distance + link . distance , origin_names + [ link . endpoint . name ], step + 1 , debug ) ) if debug : print ( \"step {} , total weight returned {} \" . format ( step , weight )) return weight chooseFromWeights ( self , weights , linklist ) \u00b6 Summary Parameters: Name Type Description Default weights TYPE Description required linklist TYPE Description required Returns: Type Description TYPE Description Source code in flee/flee.py def chooseFromWeights ( self , weights , linklist ): \"\"\" Summary Args: weights (TYPE): Description linklist (TYPE): Description Returns: TYPE: Description \"\"\" if len ( weights ) == 0 : return - 1 else : weights = self . normalizeWeights ( weights ) return np . random . choice ( list ( range ( 0 , len ( linklist ))), p = weights ) evolve ( self , ForceTownMove = False ) \u00b6 This should be completed !!! Parameters: Name Type Description Default ForceTownMove bool Description False Source code in flee/flee.py def evolve ( self , ForceTownMove = False ): \"\"\" This should be completed !!! Args: ForceTownMove (bool, optional): Description \"\"\" if self . travelling is False : if self . location . town and ForceTownMove : movechance = 1.0 else : movechance = self . location . movechance outcome = random . random () # print(movechance) if outcome < movechance : # determine here which route to take? if SimulationSettings . UseV1Rules : chosenRoute = self . selectRouteRuleset1 () else : chosenRoute = self . selectRouteRuleset2 () # if there is a viable route to a different location. if chosenRoute >= 0 : # update location to link endpoint self . location . DecrementNumAgents () self . location = self . location . links [ chosenRoute ] self . location . IncrementNumAgents () self . travelling = True self . distance_travelled_on_link = 0 finish_travel ( self ) \u00b6 checks if the agent Source code in flee/flee.py def finish_travel ( self ): \"\"\" checks if the agent \"\"\" if self . travelling : if self . places_travelled == 1 and SimulationSettings . StartOnFoot : # First journey self . distance_travelled_on_link += SimulationSettings . MaxWalkSpeed self . distance_moved_this_timestep += SimulationSettings . MaxWalkSpeed else : self . distance_travelled_on_link += SimulationSettings . MaxMoveSpeed self . distance_moved_this_timestep += SimulationSettings . MaxMoveSpeed # If destination has been reached. if self . distance_travelled_on_link > self . location . distance : self . places_travelled += 1 # remove the excess km tracked by the # distance_moved_this_timestep var. self . distance_moved_this_timestep += self . location . distance - \\ self . distance_travelled_on_link # update agent logs if SimulationSettings . AgentLogLevel > 0 : self . distance_travelled += self . location . distance # if link is closed, bring agent to start point instead of the # destination and return. if self . location . closed is True : self . location . DecrementNumAgents () self . location = self . location . startpoint self . location . IncrementNumAgents () self . travelling = False self . distance_travelled_on_link = 0 else : # if the person has moved less than the minMoveSpeed, it # should go through another evolve() step in the new # location. evolveMore = False if ( self . distance_moved_this_timestep < SimulationSettings . MaxMoveSpeed ): evolveMore = True # update location (which is on a link) to link endpoint self . location . DecrementNumAgents () self . location = self . location . endpoint self . location . IncrementNumAgents () self . travelling = False self . distance_travelled_on_link = 0 if SimulationSettings . CampLogLevel > 0 : if self . location . Camp is True : self . location . incoming_journey_lengths += [ self . timesteps_since_departure ] # Perform another evolve step if needed. And if it results # in travel, then the current travelled distance needs to # be taken into account. if evolveMore is True : ForceTownMove = False if SimulationSettings . AvoidShortStints : # Flee 2.0 Changeset 1, factor 2. if ( self . recent_travel_distance + ( self . distance_moved_this_timestep / SimulationSettings . MaxMoveSpeed ) ) / 2.0 < 0.5 : ForceTownMove = True self . evolve ( ForceTownMove ) self . finish_travel () getEndPointScore ( self , link ) \u00b6 Summary Parameters: Name Type Description Default link TYPE Description required Returns: Type Description TYPE Description Source code in flee/flee.py def getEndPointScore ( self , link ): \"\"\" Summary Args: link (TYPE): Description Returns: TYPE: Description \"\"\" # print(link.endpoint.name, link.endpoint.scores) return link . endpoint . scores [ 1 ] getLinkWeight ( self , link , awareness_level ) \u00b6 Calculate the weight of an adjacent link. Weight = probability that it will be chosen. Parameters: Name Type Description Default link Link obj Description required awareness_level int Description required Returns: Type Description TYPE Description Source code in flee/flee.py def getLinkWeight ( self , link , awareness_level ): \"\"\" Calculate the weight of an adjacent link. Weight = probability that it will be chosen. Args: link (Link obj): Description awareness_level (int): Description Returns: TYPE: Description \"\"\" # If turning back is NOT allowed, remove weight from the last location. # if not SimulationSettings.TurnBackAllowed: # if link.endpoint == self.last_location: # return 0.0 #float(0.1 / float(SimulationSettings.Softening + # link.distance)) if awareness_level < 0 : return 1.0 return float ( link . endpoint . scores [ awareness_level ] / float ( SimulationSettings . Softening + link . distance ) ) normalizeWeights ( self , weights ) \u00b6 Normalized the weight values Parameters: Name Type Description Default weights TYPE Description required Returns: Type Description TYPE Description Source code in flee/flee.py def normalizeWeights ( self , weights ): \"\"\" Normalized the weight values Args: weights (TYPE): Description Returns: TYPE: Description \"\"\" if np . sum ( weights ) > 0.0 : weights /= np . sum ( weights ) else : # if all have zero weight, then we do equal weighting. weights += 1.0 / float ( len ( weights )) return weights selectRouteRuleset1 ( self ) \u00b6 Summary Returns: Type Description TYPE Description Source code in flee/flee.py def selectRouteRuleset1 ( self ): \"\"\" Summary Returns: TYPE: Description \"\"\" linklen = len ( self . location . links ) weights = np . zeros ( linklen ) for i in range ( 0 , linklen ): if self . location . links [ i ] . endpoint . getCapMultiplier ( self . location . links [ i ] . numAgents ) <= 0.000001 : weights [ i ] = 0.0 # forced redirection: if this is true for a link, return its value # immediately. elif self . location . links [ i ] . forced_redirection is True : return i else : weights [ i ] = self . getLinkWeight ( self . location . links [ i ], SimulationSettings . AwarenessLevel ) # Throttle down weight when occupancy is close to peak # capacity. weights [ i ] *= self . location . links [ i ] . endpoint . getCapMultiplier ( self . location . links [ i ] . numAgents ) return self . chooseFromWeights ( weights , self . location . links ) selectRouteRuleset2 ( self , debug = False ) \u00b6 Summary Parameters: Name Type Description Default debug bool Description False Returns: Type Description TYPE Description Source code in flee/flee.py def selectRouteRuleset2 ( self , debug = False ): \"\"\" Summary Args: debug (bool, optional): Description Returns: TYPE: Description \"\"\" linklen = len ( self . location . links ) weights = np . zeros ( linklen ) if SimulationSettings . AwarenessLevel == 0 : return np . random . randint ( 0 , linklen ) for k , e in enumerate ( self . location . links ): weights [ k ] = self . calculateLinkWeight ( e , 0.0 , [ self . location . name ], 1 , debug ) return self . chooseFromWeights ( weights , self . location . links ) selection: docstring_style: google # this is the default inherited_members: True members: :docstring:","title":"Person"},{"location":"code_reference/flee_person/#person-class","text":"The base class for the agent object Attributes: Name Type Description distance_moved_this_timestep float Description distance_travelled int Description distance_travelled_on_link int Description home_location TYPE Description location TYPE Description places_travelled int Description recent_travel_distance float Description timesteps_since_departure int Description travelling bool Description","title":"Person class"},{"location":"code_reference/flee_person/#flee.flee.Person-methods","text":"","title":"Methods"},{"location":"code_reference/flee_person/#flee.flee.Person.calculateLinkWeight","text":"Calculates Link Weights recursively based on awareness level. Loops are avoided. Parameters: Name Type Description Default link TYPE Link class obj required prior_distance TYPE Description required origin_names TYPE Description required step TYPE Description required debug bool Description False Returns: Type Description TYPE Description Source code in flee/flee.py def calculateLinkWeight ( self , link , prior_distance , origin_names , step , debug = False ): \"\"\" Calculates Link Weights recursively based on awareness level. Loops are avoided. Args: link (TYPE): Link class obj prior_distance (TYPE): Description origin_names (TYPE): Description step (TYPE): Description debug (bool, optional): Description Returns: TYPE: Description \"\"\" weight = float ( self . getEndPointScore ( link ) / float ( SimulationSettings . Softening + link . distance + prior_distance ) ) * link . endpoint . getCapMultiplier ( link . numAgents ) if debug : print ( \"step {} , dest {} , dist {} , prior_dist {} , \" \"score {} , weight {} \" . format ( step , link . endpoint . name , link . distance , prior_distance , self . getEndPointScore ( link ), weight ) ) if SimulationSettings . AwarenessLevel > step : # Traverse the tree one step further. for k , e in enumerate ( link . endpoint . links ): if e . endpoint . name in origin_names : # Link points back to an origin, so ignore. pass else : weight = max ( weight , self . calculateLinkWeight ( e , prior_distance + link . distance , origin_names + [ link . endpoint . name ], step + 1 , debug ) ) if debug : print ( \"step {} , total weight returned {} \" . format ( step , weight )) return weight","title":"calculateLinkWeight()"},{"location":"code_reference/flee_person/#flee.flee.Person.chooseFromWeights","text":"Summary Parameters: Name Type Description Default weights TYPE Description required linklist TYPE Description required Returns: Type Description TYPE Description Source code in flee/flee.py def chooseFromWeights ( self , weights , linklist ): \"\"\" Summary Args: weights (TYPE): Description linklist (TYPE): Description Returns: TYPE: Description \"\"\" if len ( weights ) == 0 : return - 1 else : weights = self . normalizeWeights ( weights ) return np . random . choice ( list ( range ( 0 , len ( linklist ))), p = weights )","title":"chooseFromWeights()"},{"location":"code_reference/flee_person/#flee.flee.Person.evolve","text":"This should be completed !!! Parameters: Name Type Description Default ForceTownMove bool Description False Source code in flee/flee.py def evolve ( self , ForceTownMove = False ): \"\"\" This should be completed !!! Args: ForceTownMove (bool, optional): Description \"\"\" if self . travelling is False : if self . location . town and ForceTownMove : movechance = 1.0 else : movechance = self . location . movechance outcome = random . random () # print(movechance) if outcome < movechance : # determine here which route to take? if SimulationSettings . UseV1Rules : chosenRoute = self . selectRouteRuleset1 () else : chosenRoute = self . selectRouteRuleset2 () # if there is a viable route to a different location. if chosenRoute >= 0 : # update location to link endpoint self . location . DecrementNumAgents () self . location = self . location . links [ chosenRoute ] self . location . IncrementNumAgents () self . travelling = True self . distance_travelled_on_link = 0","title":"evolve()"},{"location":"code_reference/flee_person/#flee.flee.Person.finish_travel","text":"checks if the agent Source code in flee/flee.py def finish_travel ( self ): \"\"\" checks if the agent \"\"\" if self . travelling : if self . places_travelled == 1 and SimulationSettings . StartOnFoot : # First journey self . distance_travelled_on_link += SimulationSettings . MaxWalkSpeed self . distance_moved_this_timestep += SimulationSettings . MaxWalkSpeed else : self . distance_travelled_on_link += SimulationSettings . MaxMoveSpeed self . distance_moved_this_timestep += SimulationSettings . MaxMoveSpeed # If destination has been reached. if self . distance_travelled_on_link > self . location . distance : self . places_travelled += 1 # remove the excess km tracked by the # distance_moved_this_timestep var. self . distance_moved_this_timestep += self . location . distance - \\ self . distance_travelled_on_link # update agent logs if SimulationSettings . AgentLogLevel > 0 : self . distance_travelled += self . location . distance # if link is closed, bring agent to start point instead of the # destination and return. if self . location . closed is True : self . location . DecrementNumAgents () self . location = self . location . startpoint self . location . IncrementNumAgents () self . travelling = False self . distance_travelled_on_link = 0 else : # if the person has moved less than the minMoveSpeed, it # should go through another evolve() step in the new # location. evolveMore = False if ( self . distance_moved_this_timestep < SimulationSettings . MaxMoveSpeed ): evolveMore = True # update location (which is on a link) to link endpoint self . location . DecrementNumAgents () self . location = self . location . endpoint self . location . IncrementNumAgents () self . travelling = False self . distance_travelled_on_link = 0 if SimulationSettings . CampLogLevel > 0 : if self . location . Camp is True : self . location . incoming_journey_lengths += [ self . timesteps_since_departure ] # Perform another evolve step if needed. And if it results # in travel, then the current travelled distance needs to # be taken into account. if evolveMore is True : ForceTownMove = False if SimulationSettings . AvoidShortStints : # Flee 2.0 Changeset 1, factor 2. if ( self . recent_travel_distance + ( self . distance_moved_this_timestep / SimulationSettings . MaxMoveSpeed ) ) / 2.0 < 0.5 : ForceTownMove = True self . evolve ( ForceTownMove ) self . finish_travel ()","title":"finish_travel()"},{"location":"code_reference/flee_person/#flee.flee.Person.getEndPointScore","text":"Summary Parameters: Name Type Description Default link TYPE Description required Returns: Type Description TYPE Description Source code in flee/flee.py def getEndPointScore ( self , link ): \"\"\" Summary Args: link (TYPE): Description Returns: TYPE: Description \"\"\" # print(link.endpoint.name, link.endpoint.scores) return link . endpoint . scores [ 1 ]","title":"getEndPointScore()"},{"location":"code_reference/flee_person/#flee.flee.Person.getLinkWeight","text":"Calculate the weight of an adjacent link. Weight = probability that it will be chosen. Parameters: Name Type Description Default link Link obj Description required awareness_level int Description required Returns: Type Description TYPE Description Source code in flee/flee.py def getLinkWeight ( self , link , awareness_level ): \"\"\" Calculate the weight of an adjacent link. Weight = probability that it will be chosen. Args: link (Link obj): Description awareness_level (int): Description Returns: TYPE: Description \"\"\" # If turning back is NOT allowed, remove weight from the last location. # if not SimulationSettings.TurnBackAllowed: # if link.endpoint == self.last_location: # return 0.0 #float(0.1 / float(SimulationSettings.Softening + # link.distance)) if awareness_level < 0 : return 1.0 return float ( link . endpoint . scores [ awareness_level ] / float ( SimulationSettings . Softening + link . distance ) )","title":"getLinkWeight()"},{"location":"code_reference/flee_person/#flee.flee.Person.normalizeWeights","text":"Normalized the weight values Parameters: Name Type Description Default weights TYPE Description required Returns: Type Description TYPE Description Source code in flee/flee.py def normalizeWeights ( self , weights ): \"\"\" Normalized the weight values Args: weights (TYPE): Description Returns: TYPE: Description \"\"\" if np . sum ( weights ) > 0.0 : weights /= np . sum ( weights ) else : # if all have zero weight, then we do equal weighting. weights += 1.0 / float ( len ( weights )) return weights","title":"normalizeWeights()"},{"location":"code_reference/flee_person/#flee.flee.Person.selectRouteRuleset1","text":"Summary Returns: Type Description TYPE Description Source code in flee/flee.py def selectRouteRuleset1 ( self ): \"\"\" Summary Returns: TYPE: Description \"\"\" linklen = len ( self . location . links ) weights = np . zeros ( linklen ) for i in range ( 0 , linklen ): if self . location . links [ i ] . endpoint . getCapMultiplier ( self . location . links [ i ] . numAgents ) <= 0.000001 : weights [ i ] = 0.0 # forced redirection: if this is true for a link, return its value # immediately. elif self . location . links [ i ] . forced_redirection is True : return i else : weights [ i ] = self . getLinkWeight ( self . location . links [ i ], SimulationSettings . AwarenessLevel ) # Throttle down weight when occupancy is close to peak # capacity. weights [ i ] *= self . location . links [ i ] . endpoint . getCapMultiplier ( self . location . links [ i ] . numAgents ) return self . chooseFromWeights ( weights , self . location . links )","title":"selectRouteRuleset1()"},{"location":"code_reference/flee_person/#flee.flee.Person.selectRouteRuleset2","text":"Summary Parameters: Name Type Description Default debug bool Description False Returns: Type Description TYPE Description Source code in flee/flee.py def selectRouteRuleset2 ( self , debug = False ): \"\"\" Summary Args: debug (bool, optional): Description Returns: TYPE: Description \"\"\" linklen = len ( self . location . links ) weights = np . zeros ( linklen ) if SimulationSettings . AwarenessLevel == 0 : return np . random . randint ( 0 , linklen ) for k , e in enumerate ( self . location . links ): weights [ k ] = self . calculateLinkWeight ( e , 0.0 , [ self . location . name ], 1 , debug ) return self . chooseFromWeights ( weights , self . location . links ) selection: docstring_style: google # this is the default inherited_members: True members: :docstring:","title":"selectRouteRuleset2()"},{"location":"papers/papers/","text":"Talks \u00b6 Journal \u00b6 Diana Suleimenova, David Bell, and Derek Groen. A generalized simulation development approach for predicting refugee destinations . Scientific Reports , 7, 13377, 2017. DOI: 10.1038/s41598-017-13828-9 D. Suleimenova, H. Arabnejad, W. N. Edeling, and D. Groen. Sensitivity-driven simulation development: a case study in forced migration . Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences , 379, 20200077, 2021. DOI: 10.1098/rsta.2020.0077 Diana Suleimenova, Derek Groen. How policy decisions affect refugee journeys in South Sudan: a study using automated ensemble simulations . Journal of Artificial Societies and Social Simulation , 23(1), 2020. DOI: 10.18564/jasss.4193 L\u00e9a Kaufmann, Ranaivo Razakanirina, Derek Groen, Bastien Chopard. Impact of immigrants on a multi-agent economical system . PLOS ONE 13(5): e0197509. DOI: 10.1371/journal.pone.0197509 Conference \u00b6 Diana Suleimenova1, Alireza Jahani1, Hamid Arabnejad1, and Derek Groen. Forecasting Forced Migration by Coupling an Agent-based Simulation Approach with Weather Data . EGU General Assembly 2021. DOI: 10.5194/egusphere-egu21-16086 Keren Mezuman, Paulina Concha Larrauri, Upmanu Lall, Michael Joseph Puma, Derek Groen, Diana Suleimenova. Coupling Bayesian inference and agent based modeling in the context of refugee movement . AGU Fall Meeting , 2020 link Derek Groen, David Bell, Hamid Arabnejad, Diana Suleimenova, Simon JE Taylor, Anastasia Anagnostou, Towards modelling the effect of evolving violence on forced migration . Winter Simulation Conference (WSC) , pp. 297-307, 2019. DOI: 10.1109/WSC40007.2019.9004683 Christian Vanhille Campos, Diana Suleimenova, Derek Groen. A Coupled Food Security and Refugee Movement Model for the South Sudan Conflict . International Conference on Computational Science , pp. 725-732, 2019. DOI: 10.1007/978-3-030-22750-0_71 Derek Groen. Development of a multiscale simulation approach for forced migration . International Conference on Computational Science , pp. 869-875, 2018. DOI: 10.1007/978-3-319-93701-4_69 Nga Ting Chan, Diana Suleimenova, David Bell, and Derek Groen. Modelling refugees escaping violent events: a feasibility study from an input data perspective ., Proceedings of the Operational Research Society 9 th Simulation Workshop , pp. 156-163, 2018. link Diana Suleimenova, David Bell, and Derek Groen. Towards an automated framework for agent-based simulation of refugee movements ., Winter Simulation Conference (WSC) , pp. 1240-1251, 2017. DOI: 10.1109/WSC.2017.8247870 Derek Groen. Simulating refugee movements: Where would you go? , International Conference on Computational Science , pp. 2251-2255, 2016. DOI: 10.1016/j.procs.2016.05.400","title":"Publications"},{"location":"papers/papers/#talks","text":"","title":"Talks"},{"location":"papers/papers/#journal","text":"Diana Suleimenova, David Bell, and Derek Groen. A generalized simulation development approach for predicting refugee destinations . Scientific Reports , 7, 13377, 2017. DOI: 10.1038/s41598-017-13828-9 D. Suleimenova, H. Arabnejad, W. N. Edeling, and D. Groen. Sensitivity-driven simulation development: a case study in forced migration . Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences , 379, 20200077, 2021. DOI: 10.1098/rsta.2020.0077 Diana Suleimenova, Derek Groen. How policy decisions affect refugee journeys in South Sudan: a study using automated ensemble simulations . Journal of Artificial Societies and Social Simulation , 23(1), 2020. DOI: 10.18564/jasss.4193 L\u00e9a Kaufmann, Ranaivo Razakanirina, Derek Groen, Bastien Chopard. Impact of immigrants on a multi-agent economical system . PLOS ONE 13(5): e0197509. DOI: 10.1371/journal.pone.0197509","title":"Journal"},{"location":"papers/papers/#conference","text":"Diana Suleimenova1, Alireza Jahani1, Hamid Arabnejad1, and Derek Groen. Forecasting Forced Migration by Coupling an Agent-based Simulation Approach with Weather Data . EGU General Assembly 2021. DOI: 10.5194/egusphere-egu21-16086 Keren Mezuman, Paulina Concha Larrauri, Upmanu Lall, Michael Joseph Puma, Derek Groen, Diana Suleimenova. Coupling Bayesian inference and agent based modeling in the context of refugee movement . AGU Fall Meeting , 2020 link Derek Groen, David Bell, Hamid Arabnejad, Diana Suleimenova, Simon JE Taylor, Anastasia Anagnostou, Towards modelling the effect of evolving violence on forced migration . Winter Simulation Conference (WSC) , pp. 297-307, 2019. DOI: 10.1109/WSC40007.2019.9004683 Christian Vanhille Campos, Diana Suleimenova, Derek Groen. A Coupled Food Security and Refugee Movement Model for the South Sudan Conflict . International Conference on Computational Science , pp. 725-732, 2019. DOI: 10.1007/978-3-030-22750-0_71 Derek Groen. Development of a multiscale simulation approach for forced migration . International Conference on Computational Science , pp. 869-875, 2018. DOI: 10.1007/978-3-319-93701-4_69 Nga Ting Chan, Diana Suleimenova, David Bell, and Derek Groen. Modelling refugees escaping violent events: a feasibility study from an input data perspective ., Proceedings of the Operational Research Society 9 th Simulation Workshop , pp. 156-163, 2018. link Diana Suleimenova, David Bell, and Derek Groen. Towards an automated framework for agent-based simulation of refugee movements ., Winter Simulation Conference (WSC) , pp. 1240-1251, 2017. DOI: 10.1109/WSC.2017.8247870 Derek Groen. Simulating refugee movements: Where would you go? , International Conference on Computational Science , pp. 2251-2255, 2016. DOI: 10.1016/j.procs.2016.05.400","title":"Conference"}]}